#!/usr/bin/env python3
"""
Zone-Poker - WAF Detection Module
"""

import logging
from typing import Any, Dict, List, Tuple

import httpx

logger = logging.getLogger(__name__)

# A more comprehensive dictionary of WAF fingerprints.
WAF_FINGERPRINTS = {
    "Cloudflare": {
        "headers": {"server": ("cloudflare", 10)},
        "any_headers": {"cf-ray": 90, "__cfduid": 90},
        "body": {"Attention Required! | Cloudflare": 90},
    },
    "Akamai": {
        "headers": {"server": ("AkamaiGHost", 10)},
        "any_headers": {"x-akamai-transformed": 90},
        "body": {"The requested URL was rejected. Please consult with your administrator.": 90},
    },
    "AWS WAF": {
        "headers": {"server": ("awselb", 10)},
        "any_headers": {"x-amz-cf-id": 90},
        "body": {"AWS WAF": 80},
    },
    "Sucuri": {
        "headers": {"server": ("Sucuri/Cloudproxy", 90)},
        "any_headers": {"x-sucuri-id": 90},
        "body": {"Sucuri WebSite Firewall - Access Denied": 90},
    },
    "Imperva (Incapsula)": {
        "any_headers": {"x-iinfo": 90, "x-cdn": 90},
        "body": {"Request unsuccessful. Incapsula incident ID": 90},
    },
    "Wordfence": {
        "body": {
            "Generated by Wordfence": 90,
            "A potentially unsafe operation has been detected": 90,
        },
    },
}


def _check_fingerprints(response_headers: Dict[str, str], response_body: str) -> List[Tuple[str, int, str]]:
    """
    Checks response headers and body against WAF fingerprints and returns scored matches.

    Args:
        response_headers: A dictionary of the response headers.
        response_body: The text content of the response body.

    Returns:
        A list of tuples, where each tuple contains (WAF Name, Score, Reason).
    """
    evidence = []
    server_header = response_headers.get("server", "").lower()

    for waf_name, fp in WAF_FINGERPRINTS.items():
        # Check server header
        server_fp = fp.get("headers", {}).get("server")
        if server_fp and server_fp[0] in server_header:
            evidence.append((waf_name, server_fp[1], f"Server header matched '{server_fp[0]}'."))

        # Check other headers
        for header, score in fp.get("any_headers", {}).items():
            if header in response_headers:
                evidence.append((waf_name, score, f"Found characteristic header '{header}'."))

        # Check body content
        for body_str, score in fp.get("body", {}).items():
            if body_str.lower() in response_body:
                evidence.append((waf_name, score, "Response body contained a WAF block message."))

    return evidence


async def detect_waf(domain: str, timeout: int, **kwargs: Any) -> Dict[str, Any]:
    """Attempts to identify a Web Application Firewall.

    It sends both benign and malicious-like payloads and observes the server's response for fingerprints."""
    waf_info: Dict[str, Any] = {"detected_waf": "None", "reason": "", "error": None}
    benign_url = f"https://{domain}"
    malicious_url = f"https://{domain}/?s=<script>alert('xss')</script>"
    headers = {"User-Agent": "Zone-Poker WAF Detector/1.0"}

    try:
        async with httpx.AsyncClient(timeout=timeout, verify=False, headers=headers, follow_redirects=True) as client:
            all_evidence: List[Tuple[str, int, str]] = []

            # 1. Send a benign request to get a baseline
            base_response = await client.get(benign_url)
            base_headers = {k.lower(): v for k, v in base_response.headers.items()}
            base_body = base_response.text.lower()
            all_evidence.extend(_check_fingerprints(base_headers, base_body))

            # 2. Send a malicious-like request and check for changes/fingerprints
            malicious_response = await client.get(malicious_url)
            malicious_headers = {k.lower(): v for k, v in malicious_response.headers.items()}
            malicious_body = malicious_response.text.lower()
            all_evidence.extend(_check_fingerprints(malicious_headers, malicious_body))

            # 3. Check for behavioral changes (status code and content)
            if malicious_response.status_code != base_response.status_code and malicious_response.status_code in (403, 406, 429, 418):
                reason = f"Request blocked with status {malicious_response.status_code} (baseline was {base_response.status_code})."
                all_evidence.append(("Generic WAF/IPS", 60, reason))
            # Add a check for content changes, which can indicate a "soft block"
            elif any(keyword in malicious_body for keyword in ["blocked", "forbidden", "denied"]) and "cloudflare" not in malicious_body:
                # Compare content length, a much shorter response is a strong indicator of a block page
                if len(malicious_body) < 0.5 * len(base_body):
                    reason = "Response content changed significantly and contained block-related keywords."
                    all_evidence.append(("Generic WAF/IPS", 50, reason))

            # 4. Aggregate scores and determine the highest-scoring WAF
            if all_evidence:
                waf_scores: Dict[str, Dict[str, Any]] = {}
                for waf_name, score, reason in all_evidence:
                    if waf_name not in waf_scores:
                        waf_scores[waf_name] = {"score": 0, "reasons": []}
                    waf_scores[waf_name]["score"] += score
                    waf_scores[waf_name]["reasons"].append(reason)

                # Find the WAF with the highest total score
                if not waf_scores:
                    return waf_info  # No evidence found

                best_waf_name = max(waf_scores, key=lambda k: waf_scores[k]["score"])
                best_match = (
                    best_waf_name,
                    waf_scores[best_waf_name]["score"],
                    "; ".join(set(waf_scores[best_waf_name]["reasons"])),
                )

                waf_info["detected_waf"] = best_match[0]
                waf_info["reason"] = best_match[2]

    except httpx.RequestError as e:
        waf_info["error"] = f"Could not connect to the server: {type(e).__name__}"
        logger.debug(f"WAF detection failed for {domain}: {e}")
    except Exception as e:
        waf_info["error"] = f"An unexpected error occurred: {e}"
        logger.warning(f"Unexpected error in WAF detection for {domain}: {e}", exc_info=True)

    return waf_info
